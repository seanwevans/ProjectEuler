# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
# Triangle			P(3,n) = n(n+1)/2		1, 3, 6, 10, 15, ...
# Square	 		P(4,n) = n**2	 		1, 4, 9, 16, 25, ...
# Pentagonal	 	P(5,n) = n(3n-1)/2	 	1, 5, 12, 22, 35, ...
# Hexagonal	 		P(6,n) = n(2n-1)	 	1, 6, 15, 28, 45, ...
# Heptagonal	 	P(7,n) = n(5n-3)/2	 	1, 7, 18, 34, 55, ...
# Octagonal	 		P(8,n) = n(3n-2)	 	1, 8, 21, 40, 65, ...
#
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
# 1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
# 2. Each polygonal type: triangle (P(3,127)=8128), square (P(4,91)=8281), and pentagonal (P(5,44)=2882), is represented by a different number in the set.
# 3. This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
# triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

from itertools import count
from search import *

def P(k, n):
	if k == 3: return ((n * (n + 1)) // 2)
	elif k == 4: return (n * n)
	elif k == 5: return ((n * (3*n - 1)) // 2)
	elif k == 6: return (n * (2*n - 1))
	elif k == 7: return ((n * (5*n - 3)) // 2)
	elif k == 8: return (n * (3*n - 2))
	else: return None

# Generate all four digit polygonal numbers.
FourDigitPolyNums = {x:[] for x in range(3,9)}

for k in FourDigitPolyNums:
	for n in count(1):
		pkn = P(k,n)
		pknlen = len(str(pkn))
		if pknlen == 4:
			FourDigitPolyNums[k].append(pkn)
		elif pknlen == 5:
			break

# Generate a directed graph based on rules 1 and 2
AllKeys = [key for key in FourDigitPolyNums]
NumAss = {}

for key in FourDigitPolyNums:
	SearchKeys = [k for k in AllKeys if k != key]	# Rule 2
	for XNum in FourDigitPolyNums[key]:
		NumAss[XNum] = []
		for skey in SearchKeys:
			for sxnum in FourDigitPolyNums[skey]:
				if str(XNum)[-2:] == str(sxnum)[:2]:	# Rule 1
					NumAss[XNum].append(sxnum)
		
# Find a length 6 cycle
G = Directed_Graph(NumAss)
Explored = [False] * G.NumVert
G.ToString()