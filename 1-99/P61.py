# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate 
# (polygonal) numbers and are generated by the following formulae:
# Triangle	 	P_3(n) = n*(n+1)/2	 	1, 3, 6, 10, 15, ...
# Square	 	P_4(n) = n**2 			1, 4, 9, 16, 25, ...
# Pentagonal	P_5,n = n*(3*n−1)/2	 	1, 5, 12, 22, 35, ...
# Hexagonal	 	P_6(n) = n*(2*n−1)	 	1, 6, 15, 28, 45, ...
# Heptagonal	P_7(n) = n*(5*n−3)/2	1, 7, 18, 34, 55, ...
# Octagonal	 	P_8(n) = n*(3*n−2)	 	1, 8, 21, 40, 65, ...
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
# The set is cyclic, in that the last two digits of each number is the first two digits of the 
# next number (including the last number with the first).
# Each polygonal type: triangle (P_3(127)=8128), square (P_4(91)=8281), and pentagonal (P_5(44)=2882),
# is represented by a different number in the set. This is the only set of 4-digit numbers with 
# This property. Find the sum of the only ordered set of six cyclic 4-digit numbers for which each
# polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented
# by a different number in the set.

from itertools import count

def P(s,n):
	return int((n + (1/2) * (n * (s-2) * (n-1))))
	
def AdjDict(num_digits):
	adj = {}
	
	# Initialize blank dictionary
	for s in range(3,9):
		for n in count():
			psn = P(s,n)
			len_psn = len(str(psn))
			if len_psn == num_digits:
				adj[psn] = []
			if len_psn == num_digits + 1:
				break
	
	# Populate adjacency data
	for i in adj:
		for j in adj:
			if i != j:
				if str(i)[-2:] == str(j)[:2]:
					adj[i].append(j)
	
	return(adj)
		
# Create adjacency graph with all four digit polygonal numbers
adj = AdjDict(4)

# Break the graph into strongly connected components
sccs = explored = []

# Search each sub graph for a cycle of length 6 (there should only be one)
cycle_length_six = []
for graph in sccs:
	pass

# Sum the numbers in the appropriate cycle
print(sum(cycle_length_six))